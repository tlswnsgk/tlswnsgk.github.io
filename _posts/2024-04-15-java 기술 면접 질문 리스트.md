---
title:  "[기술면접] java 면접 질문 리스트"
excerpt: "java,컴퓨터 공학 면접 질문 리스트"

categories:
  - java
tags:
  - [java]

toc: true
toc_sticky: true
 
date: 2024-04-15
last_modified_at: 
---

---
<h3>1.RDBMS</h3>
> ​- RDB(Relational DataBase)<br>
관계형 데이터 모델에 기초를 둔 데이터 베이스<br>
-RDB를 생성하고 수정하고 관리할 수 있는 소프트웨어<br>
-RDBMS는 Relational DataBase Managemnt System의 약자로 관계형 모델을 기반으로 하는 DBMS의 유형<br>
-RDBMS의 테이블은 서로 연관되어 있어 일반 DBMS보다 효율적으로 데이터를 저장,구성 및 관리할 수 있다.<br>
-정규화를 통해 데이터의 중복성을 최소화하며 트랜잭션을 수행하는 것이 더 쉽다.<br>
-데이터의 원자성,일관성, 격리 및 내구성을 유지하며 데이터 무결성을 높인다.<br> 
-MySql,Oracle이 RDBMS의 몇 가지 예다.<br>


<h3>2.RestAPI</h3>
> - REST의 정의<br>
웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일입니다.<br>
구체적으로는 HTTP URI를 통해 어떤 자원인지 명시하고, HTTP Method(GET, POST, PUT, PATCH, DELETE)를 통해 해당 자원을 처리하도록 설계된 것입니다.<br>
-6가지 원칙<br>
- Uniform Interface(인터페이스 일관성)<br>
-URI로 지정한 자원에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 것을 말합니다.<br>
-HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능합니다.<br>
- Stateless(무상태)
-세션 정보나 쿠키를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만
-단순히 수행합니다.<br>
-이전 요청이 다음 요청의 처리에 연관되면 안됩니다. (이전 요청이 DB를 수정해 바뀌는 것 제외)<br>
-서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이
단순해집니다.<br><br>
- Cacheable(캐시 처리 가능)
-웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존 인프라를 그대로 활용할 수 있습니다.<br>
-HTTP가 가진 캐싱 기능 적용이 가능합니다. 그렇기에 대량의 요청을 효율적으로 처리 할 수 있습니다.<br><br>
- Client-Server(클라이언트-서버 구조)<br>
-Client는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하고 책임집니다.<br>
-REST 서버는 API 제공하고 비즈니스 로직 처리 및 저장을 책임집니다.<br>
-각각의 역할이 확실히 구분되기 때문에 서로 간 의존성이 줄어듭니다.<br><br>
- Layered System(계층화)<br>
-Client는 REST API Server만 호출합니다.<br>
-REST API Server는 다중 계층으로 구성됩니다.<br>
-보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있습니다.<br>
-PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.<br>
- Code-On-Demand(Optional)<br>
-Server가 네트워크를 통해 Client에 프로그램을 전달하면 Client에서 실행될 수 있어야합니다.<br>
-반드시 충족할 필요는 없습니다.<br><br>
> - REST API란<br>
-API(Application Programming Interface)란 프로그램과 또 다른 프로그램을 연결해주는 일종의 다리라고 볼 수 있습니다. REST기반으로 서비스 API를 구현한 것입니다.<br>
즉, HTTP 요청을 보낼 때, 어떤 URI에 어떤 메소드를 사용할지 개발자들 사이에 널리 지켜지는 약속입니다.<br><br>
-REST API 설계 기본 규칙<br>
- URI는 정보의 자원을 표현해야합니다.<br>
- 동사보다는 명사를, 대문자보다는 소문자<br>
- 자료에 따라 단수 명사, 복수 명사 구분<br>
- 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등)로 표현합니다.<br>
- URI에 HTTP Method가 들어가면 안됩니다.<br>
- URI에 행위에 대한 동사 표현이 들어가면 안됩니다.<br>
- 경로 부분 중 변하는 부분은 유일한 값으로 대체<br><br>
-REST API 설계 규칙<br>
- 슬래시 구분자( / )는 계층 관계를 나타내는데 사용합니다.<br>
- URI 마지막 문자로 슬래시( / )를 포함하지 않습니다.<br>
- 하이픈( - )은 URI 가독성을 높이는데 사용합니다.<br>
- 밑줄( _ )은 URI에 사용하지 않습니다.<br>
- URI 경로에는 소문자가 적합합니다.<br>
- 파일확장자는 URI에 포함하지 않습니다.<br><br>
  응답상태코드<br>
- 1xx : 정보 응답<br>
- 2xx : 성공 응답<br>
- 3xx : 리다이렉션 메시지<br>
- 4xx : 클라이언트 에러 응답<br>
- 5xx : 서버 에러 응답<br>
-RESTful이란<br>
RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어입니다.<br>
'REST API'를 제공하는 웹 서비스를 'RESTful'하다고 할 수 있습니다.<br>
RESTful은 REST를 REST답게 쓰기 위한 방법으로, 누군가가 공식적으로 발표한 것이 아닙니다. 즉, REST 원리를 따르는 시스템은 RESTful이란 용어로 지칭됩니다.<br>

<br>
참고 >
<a href="https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html">https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html</a> 


<h3>3.spring</h3>
> - 전자정부 표준,운영에 도움을 준다<br>
특징 DI AOP framework<br><br>
DI -  의존성 주입 - 결합도를 느슨하게 만들어 유지보수를 편리하게 한다<br><br>
AOP - 공통적인 업무(로깅,보안,트랜잭션)를 별도로 구축하여 개발자가 업무에 전념하게 하는 관점 지향 프로그래밍이다<br><br>
DAO(data access object) - db에 데이터를 조회하거나 조작하는 기능들을 전담.<br><br>
DTO(data transfer object) - 계층 간 데이터 교환을 하기 위해 사용하는 객체. 로직을 가지지 않는 순수한 데이터 객체<br><br>
>MVC모델<br>
model은 정보 또는 데이터를 나타내는데 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야한다<br><br>
view는 input 또는 textarea와 같은 유저인터페이스 요소이며 데이터를 입력 또는 출력하여 볼 수 있는 화면이다<br><br>
controller는 모델과 뷰를 잇는 중간 다리 역할을 하며 view에서 행한 이벤트를 처리하는 부분이다<br><br>
view에서 입력한 정보를 컨트롤러로 보내고 컨트롤러는 model을 통해서 데이터를 가져오고 그 정보를 view로 화면에 나타낸다<br><br>
사용 이유는 소스를 분리함으로서 각 소스의 목적이 명확해지고 유지보수가 편리하기 때문이다<br>

<h3>4.was</h3>
> - 웹 어플리케이션 서버<br><br>
DB조회나 로직 처리를 요구하는 동적 컨텐츠를 제공하기 위해 만들어진 어플리케이션 서버<br>
업무처리하는 비니지스 로직을 수행한다<br>
ex) 톰캣<br><br>

<h3>5.쿠키와 세션</h3>
> - 세션은 pc에는 세션아이디만 저장하고 로그인값은 서버에 저장<br>
세션은 저장 데이터에 한계가 없고 보안에 우수하지만 쿠키에 비해 처리 속도가 느리다<br>
쿠키는 아이디와 로그인 값 둘 다 pc에 저장<br>
쿠키는 클라이언트에 저장 한계가 있고 보안에 취약하다<br><br>

<h3>6.객체지향 프로그래밍</h3>
> - 필요한 데이터를 객체로 생성하여 각 객체간의 상호작용을 통해 로직을 구성하는 프로그래밍<br>
특징<br>
캡슐화(정보은닉) - 낮은 결합도를 유지할 수 있도록 설계하는 것<br>
다형성(오버라이딩하여 다양하게 사용)<br>
상속 - 다른 클래스를 외부로부터 은닉하는 캡슐화의 일종<br>
추상화 - 추상적인 개념에 의존하여 설계해야 유연함을 갖출 수 있다.<br>

​
<h3>7.rest api</h3>
> - 클라이언트쪽에 json방식으로 데이터를 주기위해 rest의 원리를 따르는 api<br>


<h3>8.네트워크 osi 7계층</h3>
> - OSI 7계층이란, 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약<br>
7계층을 나누는 이유? 통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문이다<br>
1계층 : 물리계층  전송하는데 필요한 기능을 제공 ( 통신 케이블, 허브 )<br>
2계층 : 데이터링크 계층  송/수신 확인. MAC 주소를 가지고 통신함 ( 브릿지, 스위치 )<br>
3계층 : 네트워크 계층  패킷을 네트워크 간의 IP를 통해 데이터 전달 ( 라우팅 )<br>
4계층 : 전송 계층  두 host 시스템으로부터 발생하는 데이터 흐름 제공<br>
5계층 : 세션 계층  통신 시스템 사용자간의 연결을 유지 및 설정함.<br>
6계층 : 표현 계층  세션 계층 간의 주고받는 인터페이스를 일관성있게 제공<br>
7계층 : 응용 계층 사용자가 네트워크에 접근할 수 있도록 서비스 제공<br>

<h3>9.컴파일 과정</h3>
> - java의 컴파일 과정을 설명하세요.<br>
컴파일이란 고급언어로 작성된 .java 파일을 기계어인 byte code 즉 .class 파일로 변환하는 과정을 말합니다.<br>
컴파일 과정<br>
javac 컴파일러를 사용해 .java 소스 파일을 컴파일하고, 바이트코드로 변환된 .class 파일을 생성.<br>
컴파일된 바이트코드인 .class파일을 클래스로더에 전달.<br>
클래스로더는 동적 로딩을 통해 필요한 클래스를 로딩 및 링크하여 런타임 데이터 영역인 jvm의 메모리에 올리고.<br>
마지막으로 실행엔진은 jvm 메모리에 올라온 바이트코드들을 인터프리터 방식 혹은 jit 컴파일러 방식으로 실행.<br>

<h3>10.string, stringbuffer, stringbulider 차이</h3>
> - String은 불변객체. 한 번 생성된 객체의 값을 변경할 수 없으며 문자열을 조작할 때 마다 새로운 String 객체가 생성되어 메로리를 차지<br>
연산이 많은 문자열에서는 작업 효율이 떨어질 수 있다.<br>
그러나 불변성 덕분에 스레드 세이프하고, String 객체를 자유롭게 공유할 수 있어 성능상 이점이 있을 수도 있다.<br><br>
 - StringBuffer은 가변 객체.문자열 조작시 기존 객체의 값을 변경.<br>
멀티 스레드 환경에서 동기화를 지원하여 스레드 세이프. 하지만 동기화로 인한 오버헤드가 있어 단일 스레드 환경에서는 성능이 저하될 수 있다.<br><br>
 - StringBulider은 가변객체. 문자열 조작시 기존 객체의 값을 변경.<br>
동기화를 지원하지 않아 스레드 세이프하지 않음. 하지만 동기화에 따른 오버헤드가 없기 떄문에 단일 스레드 환경에서는 더 높은 성능을 제공.<br><br>

<h3>11.java 접근제어자의 종류와 특징</h3>
> - java 접근제어자의 종류와 특징
- public 클래스,메소드,변수는 다른 패키지의 모든 클래스에서 접근.<br>
- protected 변수와 메소드는 같은 패키지 내의 다른 클래스와, 해당 클래스를 상속받은 자식클래스에서도 접근.<br>
일반적으로 오버라이드 할 수 있는 메서드나 변수를 선언할 떄 사용.<br>
- default 접근제어자를 명시하지 않는 경우로 클래스,멤버변수 메서드는 같은 패키지 내의 클래스에서만 접근.<br>
- private 멤버변수와 메서드는 오직 선언된 클래스 내부에서만 접근.<br>
객체의 내부 상태를 캡슐화,외부로부터 보호할 떄 사용한다.<br>
(캡슐화는 객체지향 패러다임 중 하나로 상태와 행위를 하나의 단위로 묶는 것을 의미.)<br>

<h3>12.클래스, 객체, 인스턴스의 차이</h3>
> - 클래스는 객체지향 프로그래밍에서 특정 개체의 속성과 행위를 정의하는 설계도라고 할 수 있다.<br>
클래스는 멤버변수와 메서드로 구성되며 멤버변수는 해당 클래스의 객체들이 가질 수 있는 상태를 정의하고, 메서드는 객체들이 수행할 수 있는 행위를 정의<br>
- 객체는 클래스에 의해 정의된 설계도를 따라 만들어진 실체, 객체는 클래스의 인스턴스이다. 객체는 메모리에 할당되며 각 객체는 고유한 상태를 가지고<br>
클래스에 정의된 행위(메소드)를 수행할 수 있습니다.<br>
- 인스턴스는 클래스의 객체를 의미.<br> 클래스를 통해 객체를 생성할 때마다 새로운 인스턴스가 생성되는 것.<br>
인스턴스는 클래스에 정의된 속성과 행위를 가진 객체로 각 인스턴스는 고유한 상태를 가집니다.<br>
객체가 특정 클래스의 인스턴스라는 것은 해당 객체가 해당 클래스의 설계도이며, 객체는 클래스에 정의된 속성과 행위를 가진 실체입니다.<br>
인스턴스는 클래스의 객체를 나타내는 용어로 사용되며 클래스로 부터 생성된 객체를 의미.<br>

<h3>13.Call by value</h3>
> - Call by value<br>
- Call by value 방식은 함수에 인자를 전달할 때 인자값을 복사하여 전달하는 방식<br>
원본 데이터와 전달된 복사본이 서로 다른 메모리 주소를 가지기 떄문에,<br>
함수 내에서 인자의 값을 변경해도 원본 데이터에는 영향을 미치지 않는다.<br>

<h3>14.java8의 특징</h3>
> java8의 특징<br>
java에 함수형 프로그래밍이 처음 도입된 버전,<br>
stream API, Lamda표현식, Method Reference, Default Method, Optional Class등이 있다.<br>

<h3>15.Optional 클래스란?</h3>
> - Optional 클래스는 무엇인가?
Optional 클래스는 Wrapper 클래스로 값이 존재할 수도 있고 없을 수도 있는 상황을 명시적으로 처리할 수 있다.<br>
이를 통해 Null point Exception 문제를 해결할 수 있으며, 가독성 높은 코드를 작성할 수 있다.<br>
값의 존재 여부를 체크하고 값이 없는 경우에 대한 기본 처리를 할 수 있다.<br>

<h3>16.Stream API란?</h3>
> - Stream API란?
자바에서 일련의 데이터 요소인 배열이나 컬렉션 등의 데이터를 처리하기 위한 api.<br>
Stream API의 특징은 멀티스레드를 활용해서 병렬로 연산을 수행할 수 있고,<br>
내부 반복연산을 수행하기 떄문에 코드가 매우 간단해 진다.<br>

<h3>17.Lambda Expression이란?</h3>
>Lambda Expression이란?<br>
Lambda Expression이란 Functional interface를 구현하는 객체를 만들지 않고도 메서드로 전달할 수 있는<br>
익명 함수를 하나의 식으로 표현할 수 있도록 단수화한 것.<br>
즉, 특정 메소드 사용을 위해 일회용 객체를 만들지 않아도 되기 떄문에 간단하게 작성이 가능,가독성이 증가<br>
너무 남용하면 디버깅이 어렵다는 단점이 있다.<br>

<h3>18.java 프로그래밍이란?</h3>
>java 프로그래밍이란<br>
자바란 객체지향 프로그래밍 언어이다.<br>
jvm위에서 실행되기 떄문에 운영체제에 독집적이며 웹이나 모바일어플리케이션, 서버 등<br>
다앙햔 분야에서 사용되고 있다.<br>

<h3>19.java se와 java ee 애플리케이션 차이</h3>
>java se와 java ee 애플리케이션 차이<br>
java se는 기본적인 java프로그래밍 기능을 제공하며, 일반적으로 소규모 웹 어플리케이션 개발에 사용.<br>
반면, java ee는 se를 기반으로 확장된 기능을 제공하는 엔터프라이즈 에디션,<br>
대규모 기업 어플리케이션 개발에 사용되는 다양한 고급 기능을 제공<br>

<h3>20.Java 언어의 장단점</h3>
> - 장점 : <br>
  1. 운영체제에 독립적이다. jvm위에서 동작하기 떄문.<br>
  2. 객체지향 언어 : 객체지향의 특징이 캡슐화, 상속, 추상화, 다형성이 적용된 언어이다<br>
  3. 자동으로 메모리를 관리해준다 : jvm에서 가비지콜렉터가 데몬쓰레드에 의해 가비지콜렉션이 일어나<br>
별도의 메모리 관리가 필요 없다.<br>
  1. 오픈소스이다 : openjdk가 오픈소스이고, ㅇ픈소스 라이브러리가 풍부하다<br>
  2. 멀티쓰레드를 지원 : 자바는 스레드 생성 및 제어에 관련된 라이브러리 api를 제공 <br>
  3. 동적 로딩 지원 : 각 객체가 필요한 시점에 클래스를 동적 로딩하여 생성<br>
- 단점 : <br>
  1. c나 c++에 비해 비교적 속도가 느리다 : jvm에 의해 기계어로 번역되고 실행하는 과정을 거쳐 <br>
  비교적 느리다는 단점이 있지만, 하드웨어의 성능 향상과 바이트코드를 기계어로 변환해주는 jit 컴파일러 같은<br>
  기술 적용으로 jvm의 기능이 향상,속도 문제가 개선되었긴 하다<br>

  <h3>21.java의 데이터 타입</h3>
  > java의 데이터 타입<br>
  - 기본자료형 <br>
   실수형인 float,double <br>
   논리형인 boolean <br>
   문자형인 char가 있다.<br>
   기본 자료형은 메모리의 stack 영역에 저장이 된다.<br>
   - 참조자료형 <br>
  기본 자료형을 제외하면 모두 참조자료형이다.<br>
  new 키워드를 사용해 객체를 생성하여 생성된 객체의 주소를 참조하는 타입.<br>
  참조 자료형에는 클래스,인터페이스,배열 enum등이 있다.<br>
  객체가 생성될 때 heap 메모리에 저장되며 참조하는 변수가 없을 때 gc에 의해 파괴<br>

  <h3>22.Wrapper Class</h3>
  >Wrapper Class
  기본타입의 데이터 객체로 취급해야 하는 경우가 있다.<br>
  메소드의 인수로 객체 타입만 요구되거나 컬렉션 프레임 워크를 사용하는 경우 기본 타입의 데이터를
  그댈 사용할 수 없다. 이때 기본 타입의 데이터를 객체로 변환해주는 클래스가 Wrapper Class.<br>
  Wrapper Class는 각각의 타입에 해당하는 데이터를 전달 받아 해당 값을 가지는 객체로 만들어 준다.
  이러한 래퍼 클래스는 java.lan 패키지에 포함되어 제공된다.<br>
  추가적으로 기본자료형과의 차이점은 null값을 지원하며 객체의 값을 비교하기 위해서는
  == 동등연산자가 아닌 equals() 메소드를 사용해야 한다는 차이가 있다.<br> 

<h3>23.OOP의 4가지 특징</h3>
>추상화,캡슐화,상속,다형성<br>
- 추상화 : OOP에서 중요한 정보만 객체의 인터페이스로써 표시하고 구현 세부 정보를 숨길 수 있는 OOP의 중요한 기능<br>
- 캡슐화 : 데이터와 프로세스를 하나의 객체에 위치하도록 만드는 것 <br>
이를 통해 시스탬의 결합도는 떨어지고 응집도는 올라 시스템 전체는 유지보수하기 쉬워진다.<br>
- 상속 : 부모 객체의 특징을 물려받는 것. 인터페이스 상속과 클래스 상속으로 나뉘고,<br>
이를 통해 모듈의 재사용성이 높아지고, 다형성을 구현할 수 있다. 무분별한 상속의 남용은 시스템의 결합도를 올려 추후 유연해지지 못해 자제해야한다.<br>
- 다형성 : 같은 요청으로부터 응답이 객체의 타입에 따라 다르게 나타나는 것. 이를 통해 객체지향은 더 유연한 설계를 가줄 시 있다.<br>

>다형성의 장점
1. 여러객체를 하나의 타입으로 관리하니 유지보수가 용이해 집니다.<br>
상위클래스의 상속을 받는 자식클래스의경우 상위클래스의 변경사항이 생겼을 때 상위 클래스만 수정하는것으로 유지보수를 쉽게 할 수 있습니다.<br>
2. 확장성이 좋은 코드를 작성할 수 있습니다.<br>
새로운 기능이 추가되어야 할 때 기존의 코드를 변경하지 않고 인터페이스의 구현체를 만듦으로써 확장성이 향상됩니다.<br>
3. 결합도가 강하지 않은 프로그래밍을 할 수 있습니다.<br>
추상클래스나 인터페이스를 상속받아 기능을 구현함으로써 구체적인 구현에 대한 의존성을 가지지 않습니다.<br>

<h3>24.OOP의 5대 원칙</h3>
>- S: 단일 책임 원칙(SRP,Single Responsibilty Principle)
단익 책임 원칙이란 하나의 클래스가 변경되는 이유는 하나뿐이어야한다. -> 하나의 클래스는 하나의 원칙만 가져야한다.<br>
ex) Controller에서 비즈니스 로직을 처리한다면 클라이언트의 요청과 응답을 처리하는 역할과 비즈니스로직 처리역할 둘 다 하게됨으로 단일책임원칙에 위배됩니다. Controller는 요청과 응답을 Service는 비즈니스로직을 처리하는것이 단일책임 원칙을 지키는 것 입니다.<br><br>
- O: 개방-폐쇄 원칙(OCP, Open Closed Principle)<br>
자신의 확장에는 열려있고 주변의 변화에는 닫혀있어야 한다.<br>
기존의 코드를 변경하지 않고 새로운 기능을 추가할 수 있어야한다.<br>
ex) 가장 좋은 예는 JDBC 인터페이스라고 할 수 있습니다. JDBC인터페이스로 표준화 하지 않았다면 DB를 바꿀 때 마다 각자 제공하는 API에 따라 코드를 수정했어야 했을 것 입니다. 하지만 JDBC 인터페이스를 제공함으로써 Connection을 설정하는 부분만 해당 드라이버로 수정해 주면 DB를 교체할 수 있습니다.<br><br>
- L: 리스코프 치환 원칙(LSP, Liskov Substitution Principle)<br>
하위클래스는 상위클래스의 역할을 하는데 문제가 없어야 한다.<br>
자식클래스는 부모클래스의 역할을 모두 할 수 있어야한다.<br><br>
- I: 인터페이스 분리 원칙(ISP, Interface Segregation Principle)<br>
하나의 일반적인 인터페이스보다는 여러개의 구체적인(클라이언트에 특화된) 인터페이스를 사용해야한다.<br><br>
- D: 의존 역전 원칙(DIP, Dependency Inversion Principle)<br>
의존관계를 맺을 때 변화하기 쉬운것보다 거의 변화하지 않는것에 의존해야한다.<br>
구체화에 의존하지 말고 추상화에 의존해야한다. -> 구현클래스에 의존하지 말고 인터페이스에 의존해야한다.<br><br>

<h3>25.객체지향이란?</h3>
>객체지향이란?<br>
객체란 현실세계의 실체 및 개념을 반영하는 상태와 행위를 정의한 데이터의 집합
객체지향 프로그래밍이란 각자의 역할을 지닌 객체들끼리 서로 메세지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것<br>

<h3>26.Java의 non-static 멤버와 static 멤버의 차이</h3>
> - non-static멤버는 인스턴스멤버라고 부르며 객체 생성시 heap영역에 생성되고 객체마다 별도로 존재한다.<br>
객체 생성시에 생성되며 객체가 사라지게 되면 인스턴스 멤버도 사라지게 된다.<br>
인스턴스 멤버는 객체 내에 각각의 공간을 유지하여 다른 객체와 공유되지 않는다.<br><br>
- static 멤버는 클래스 멤버라고 부르며 객체 내부가 아닌 컴파일시 static영역에 생성.<br>
객체를 생성하지 않아도 이미 생성되어 있기 떄문에 객체 생성 없이 사용이 가능,프로그램이 종료시 사라진다<br>
클래스 멤버는 동일한 모든 클래스의 모든 객체들에 의해 공유됨.<br>
static은 공통속성으로 클래스변수에 붙이거나 인스턴스멤버를 사용하지 않는 메서드일 떄 사용.<br><br>
- 지역변수?<br>
메서드 안에 생성되는 변수를 말하며 메서드가 실행될 떄 생성되고 메서드가 종료되면 사라진다.<br><br>

<h3>27.Java의 main 메서드가 static인 이유</h3>
> -public static void main(String[] args){}의 의미 <br>
main()메서드는 프로그램이 실행되는 시작과 끝이되는 지점입니다.<br>
 JRE는 프로그램 안에 main()메서드가 있는지 확인한 후 main()메서드를 실행하게 됩니다.<br>
  main()메서드가 끝나면 JRE는 JVM을 종료하고 JRE자체도 메모리에서 사라지게됩니다. <br>
이런 특성을 기반으로 선언문을 하나씩 뜯어보면<br>
-public : 어디에서나 접근이 가능해야합니다.<br>
-static : 프로그램 실생 순간에 메모리에 할당되어야 합니다. 가비지 컬렉터의 정리 대상이 되어서는 안되기 때문입니다.<br>
-void : main()메소드가 끝나게 되면 프로그램도 종료되므로 리턴값을 사용할 호출자가 없기 때문입니다.<br>
-main() : 관례적으로 프로그램의 시작점을 main으로 사용하고 있습니다.<br>
-String[] args : 프로그램 실행시에 첫 스레드인 main에게 데이터를 넘겨주고 싶을 때를 위한 파라미터입니다.<br><br>

<h3>28.Java의 final 키워드 (final/finally/finalize)</h3>
>final는 변수나 메서드, 클래스가 변경 불가능하도록 만드는 예약어 입니다.<br>
final 변수의 경우 해당 변수의 값은 변경이 불가능해집니다.<br>
final 메서드는 해당 메서드를 오버라이드할 수 없습니다.<br>
final 클래스는 해당 클래스의 하위 클래스를 정의할 수 없습니다.<br>
finally는 try/catch 블록이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용됩니다.<br>
예외가 발생하더라도 항상 실행됩니다.<br>
finalize() 메서드는 가비지콜렉터가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출됩니다.<br><br>

<h3>29.오버로딩과 오버라이딩의 차이</h3>
>오버라이딩이란 서브클래스가 상속받은 메소드를 클래스에 맞게 재구현 하는 것을 의미,<br>
오버로딩이란 동일한 메서드 이름이지만 매개 변수 타입이나 개수가 다른 즉,
다른 명세를 가진 함수를 같은 클래스 내에 만드는 것을 의미.<br><br>

<h3>30.업캐스팅, 다운캐스팅</h3>
>Java에서는 슈퍼 클래스의 변수에 서브 클래스의 객체가 들어가는 것을 업캐스팅이라 하고, 업캐스팅 된 변수의 타입을 서브 클래스로 변경하는 것을 다운 캐스팅이라고 합니다. 서브 클래스 객체는 슈퍼 클래스의 메소드 명세를 상속 받기 때문에 슈퍼 클래스의 변수에 들어가 슈퍼 클래스 인 것처럼 사용될 수 있고, 업 캐스팅 된 변수의 타입이 다시 서브 클래스로 돌아와 본인의 클래스 객체인 것처럼 사용할 수 있습니다.<br><br>

<h3>31.인터페이스와 추상 클래스의 차이(Interface vs Abstract Class)</h3>
> - 추상클래스는 abstract키워드로 선언되어 있거나 클래스에 하나 이상의 추상메소드가 포함되어있는 클래스입니다. 추상메서드가 없어도 추상클래스로 선언할 수 있으나 하나라도 있으면 무조건 추상클래스로 선언되어야 합니다.<br>
기존의 클래스에서 공통적으로 사용될 수 있는 부분을 추상화 하여 추상클래스를 만듭니다.<br>
단독으로는 객체를 생성할 수 없으며, 상속을 위한 상위 클래스로 활용하기 위해 사용합니다.<br>
즉, 추상 클래스의 추상 메서드를 하위 클래스가 구체화하여 기능을 확장하는 데 목적이 있습니다.<br>
- 인터페이스는 interface 키워드를 사용하여 선언하며, 추상메서드의 집합이라고 할 수 있습니다.<br>
내부에 구현되어있는것이 전혀 없기 때문에 인터페이스를 implement한 클래스에서 추상메서드를 구현하여 사용합니다.<br>
구현 객체의 같은 동작을 보장하기 위한 목적으로, 공통적으로 사용되는 기능을 명시하고 구현을 강제하기 위해 사용됩니다.<br>
- 차이점
서로 다른 목적을 가지고 있습니다.<br>
추상클래스는 추상메서드를 하위클래스가 구체화 하여 기능을 확장하는데 목적이 있습니다.<br>
인터페이스는 정의된 기능 구현을 강제하여 상속받은 클래스들의 같은 동작을 보장하는데 목적이 있습니다.<br>
추상클래스는 단일 상속이지만 인터페이스는 다중상속이 가능합니다.<br><br>

>인터페이스 사용의 장점
1. 선언과 구현을 분리하여 변경에 유리해집니다. 기능변경이 필요할 때 기존 코드를 변경하는것이 아닌 구현체를 추가하여 변경할 수 있습니다.<br>
2. 표준화가 가능합니다. 가장 좋은예로 JDBC인터페이스를 들 수 있습니다. 데이터베이스의 api를 표준화 함으로써 어떤 dbms를 사용하더라도 똑같은 방식으로 다룰 수 있습니다.<br>
3. 서로 관계없는 클래스들의 관계를 맺어줄 수 있습니다. 다형성을 지원하여 다양한 객체들을 동일한 타입으로 참조하고 사용할 수 있습니다.<br><br>

<h3>32.was와 web서버란?</h3>
>was란 웹어플리케이션서버로써 웹 서버와 데이베이스 서버 사이에서 동작하는 서버로,클라이언트 요청에 따라 비즈니스 로직을 처리하고 동적인 웹 페이지와 서비스를 제공하는 역할을 합니다.<br>
 was는 jsp,sevlet등과 같은 다양한 웹 프로그래밍 기술을 지원함니다. tomcat이 대표적인 was입니다.<br>
톰켓은 자바 서블릿과 jsp를 실행할 수 있는 환경을 제공합니다.<br>
웹 서버란 클라이언트로부터 http요청을 받아 html, 이미지 등의 정적인 컨텐츠를 제공하는 서버입니다.<br>

<h3>33.서블릿</h3>
>서블릿이란 java에서 http요청과 응답을 처리하기 위한 환경을 제공하는 java기반의 서버사이드 기술입니다.<br>
 클라이언트의 요청을 받아 동적인 웹 페이지를 생성하기 위한 기술로 jsp와 함께 많이 사용됩니다.<br>
  jsp는 내부적으로 서블릿으로 변환되어 실행됩니다.<br>


---