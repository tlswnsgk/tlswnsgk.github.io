---
title:  "[잡학 정의] Redis"
excerpt: "Redis을 알아보자"

categories:
  - 잡학사전
tags:
  - [Redis]

toc: true
toc_sticky: true
 
date: 2024-05-28
last_modified_at: 
---                                          
---
<h1>Redis란?</h1>
- 고성능 Key-Value 구조의 저장소<br>
- 비정형 데이터를 저장, 관리하기 위한 오픈 소스 기반의 NoSQL<br>
- In-Memory 데이터 구조를 가진 저장소<br>
- DB, Cache, Message, Queue, Shared Memory 용도로 사용됨<br>
  웹 서버의 부담을 획기적으로 줄이고, 고속으로 데이터 제공이 가능<br><br>

>✔️인메모리 (In-Memory)
- 컴퓨터의 주기억장치인 RAM에 데이터를 올려서 사용하는 방법
- RAM에 데이터를 저장하게 되면 메모리 내부에서 처리가 되므로 
데이터를 저장/조회할 때 하드디스크를 오고 가는 과정을 거치지 않아도 되어 속도가 빠름<br><br>
But, 서버의 메모리 용량을 초과하는 데이터를 처리할 경우,
RAM의 특성인 휘발성에 따라 데이터가 유실될 수 있음

>💡기존 DB가 있는데도 Redis를 사용하는 이유?<br>
DB는 데이터를 디스크에 직접 저장(write)하기 때문에 서버에 문제가 발생하여 다운되더라도 데이터가 손실되지 않는데<br>
매번 디스크에 접근해야하기 때문에 사용자가 많아질 수록 부하가 많아져서 느려질 수 있어서 캐시 서버를 도입하여 사용해야한다.<br>
이 캐시 서버로 이용할 수 있는 것이 바로 Redis이다.<br><br>
⠀
👉 같은 요청이 여러번 들어올 때 Redis를 사용함으로써<br>
매번 DB를 거치지 않고 캐시 서버에서 저장해놨던 값을 바로 가져와<br>
DB의 부하를 줄이고 서비스의 속도도 느려지지 않게 할 수 있다 <br>

<h1>Redis의 특징?</h1>
- Key, value 구조.<br>
- 빠른 처리 속도<br>
   ➜ 디스크가 아닌 메모리에서 데이터를 처리하기 떄문에 속도가 빠름<br>
- Data type(Collection)을 지원<br>
  ![image](https://github.com/tlswnsgk/-/assets/110441845/978898f9-5621-4270-99e0-44d8e5f8596a)

>Ex.
DB에 데이터를 저장하고, 저장된 데이터를 정렬해서 다시 읽어오는 과정은 디스크에 직접 접근해야하기 때문에 시간이 걸리는데,<br>
인메모리 DB인 Redis를 사용하고 Redis에서 제공하는 Sorted-Set 자료구조를 사용하면 좀 더 빠르고 간단하게 데이터 정렬 가능<br>

- AOF, RDB 방식<br>
  
- 누가 언제 만들어낸 이슈인지도 알 수 있다.<br>
- 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다.<br>
  ➜인메모리 데이터 저장소가 가지는 휘발성의 특성으로 데이터가 유실될 경우를 방지하여 백업 기능을 제공<br>

>-AOF (Append On File) 방식<br>
➜ Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태<br><br>
RDB(Snapshotting) 방식<br>
➜ 순간적으로 메모리에 있는 내용 전체를 디스크에 담아 영구 저장하는 방식<br>

- Redis Sentinel 및 Redis Cluster를 통한 자동 파티셔닝을 제공<br>
➜ Master와 Slaves로 구성하여 여러대의 복제본을 만들 수 있고, 여러대의 서버로 읽기를 확장 가능<br>

>✔️ 파티셔닝 ( Partitioning )<br>
다수의 Redis 인스턴스가 존재할 때 데이터를 여러 곳으로 분산 시키는 기술<br>
각 Redis 인스턴스는 전체 키 중 자신에게 할당된 일부 파티션의 키들만 관리하게 됨<br>

- 다양한 프로그래밍 언어 지원<br>
- 싱글 스레드<br>
➜ 한번에 하나의 명령만 수행이 가능하므로 Race Condition이 거의 발생하지 않음<br>
>✔️ Race condition<br>
- 공유 자원에 대해 여러 프로세스가 동시에 접근을 시도할 때, 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태<br>
- 즉, 두개의 스레드가 하나의 자원을 놓고 서로 사용하려고 경쟁하는 상황에서 발생<br>
- 프로그램의 일관성과 정확성을 손상시킬 수 있음<br>
  Ex.<br>
  두개의 스레드 A, B가 X라는 공유변수를 사용하는데, A의 역할은 X에 + 1 후 저장 / B의 역할은 X에 - 1 후 저장일 때<br>
  A가 X를 읽은 후 B가 실행되기 전에 결과를 저장한다고 하면, A의 결과가 스레드 B의 결과데 덮어씌워지게 됨<br>

<h1>✔ Redis 사용 시 주의할 점</h1>
- 시간 복잡도<br>
  ➜ Single Threaded(싱글 스레드) 사용으로 한번에 하나의 명령만 수행이 가능하므로 처리 시간이 긴 요청의 경우 장애가 발생<br>
- 메모리 단편화<br>
  ➜ 크고 작은 데이터를 할당하고 해제하는 과정에서 메모리의 파편화가 발생하여 응답 속도가 느려질 수 있음<br>
>✔️ 메모리 단편화 (Memory Fragmentation)<br>
![image](https://github.com/tlswnsgk/-/assets/110441845/a9bb793e-ba0b-48d0-a2c5-6dcb2c87cdda)<br>
➜ RAM에서 메모리를 할당받고 해제하는 과정에서 위와같이 부분부분 빈 공간이 생기는데,<br>
새로운 메모리 할당 시에 사용 가능한 메모리가 충분히 존재하지만 메모리의 크기만큼의 부분이 없어 마지막 부분에 할당되어 메모리 낭비가 심하게 됨<br><br>
➜ 이 현상이 계속되면 실제 physical 메모리가 커져 프로세스가 죽는 현상이 발생 할 수도 있으므로, redis를 사용 시에 메모리를 적당히 여유있게 사용하는 것이 좋음

<h1>✔ Redis 적용 사례</h1><br>
e-commerce와 쇼핑몰 같은 서비스에서 결제 등 동시성 문제를 해결하기 위한 방법으로 사용된다<br>
![image](https://github.com/tlswnsgk/-/assets/110441845/2f6ee92f-442c-4013-bc21-0e192b54c812)<br>
>재고 ≥ 결제중 상품수량(redis) + 결제하려는 상품수량<br>

예를 들어 결제 중인 고객이 여러 명이고 고객들이 구매하고자 하는 재고가 현 재고보다 많을시<br>
문제가 발생하기 때문에<br>
결제 중인 상품수량을 체크하여 로직을 구현하면 된다.<br><br>

아직 Redis를 사용해본 적이 없기에 다음에는 해당 포스팅을 활용해 로직을 구현해볼 수 있도록 하겠다.<br>
---